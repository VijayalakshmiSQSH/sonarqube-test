name: SonarQube Scan

on:
  push:
    branches: [ "main" ]
  pull_request:

jobs:
  sonar:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 

      - name: Run SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@v2.0.2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: SonarQube Quality Gate check
        uses: sonarsource/sonarqube-quality-gate-action@v1.1.0
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: Get email recipient
        if: always()
        id: email
        # GITHUB_TOKEN is built-in and always valid; fixes "Bad credentials"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEFAULT_EMAIL: ${{ secrets.DEFAULT_EMAIL }} # Required fallback
        run: |
          # ----------------------------------------------------------------------
          # DYNAMIC EMAIL RESOLUTION LOGIC
          # Priority:
          # 1. Payload (Pusher Email) - valid for Pushes
          # 2. API Profile - valid if user has public email
          # 3. Git History Deep Scan - looks for past commits with real email
          # 4. Default Secret - final safety net
          # ----------------------------------------------------------------------

          ACTOR="${{ github.actor }}"
          echo "Resolving email for Actor: $ACTOR"
          
          # Function to validate email (must not be empty, null, or noreply)
          validate_email() {
            local email=$1
            if [[ -n "$email" ]] && [[ "$email" != "null" ]] && [[ "$email" != *"noreply.github.com"* ]]; then
              return 0 # Valid
            else
              return 1 # Invalid
            fi
          }

          FOUND_EMAIL=""

          # [Attempt 1] Check Event Payload (Works for standard Pushes)
          PAYLOAD_EMAIL="${{ github.event.pusher.email }}"
          if validate_email "$PAYLOAD_EMAIL"; then
            echo "‚úÖ Found valid email in push payload."
            FOUND_EMAIL="$PAYLOAD_EMAIL"
          fi

          # [Attempt 2] Check GitHub API (Works if user profile is Public)
          if [[ -z "$FOUND_EMAIL" ]]; then
            echo "üîç Payload email invalid/missing. Checking GitHub API..."
            # || true prevents script crash on 404/403
            API_EMAIL=$(gh api "users/$ACTOR" --jq '.email' 2>/dev/null || true)
            
            if validate_email "$API_EMAIL"; then
              echo "‚úÖ Found valid email in Public Profile API."
              FOUND_EMAIL="$API_EMAIL"
            fi
          fi

          # [Attempt 3] Deep Git History Scan (The "Magic" Step)
          # If the user is merging via Web UI (noreply), this scans their 
          # previous 500 commits to find ONE where they used a real email.
          if [[ -z "$FOUND_EMAIL" ]]; then
            echo "üîç API failed. Scanning last 500 commits for a real address..."
            
            # 1. Get emails by this author
            # 2. Filter OUT noreply
            # 3. Take the first one found
            HISTORY_EMAIL=$(git log --author="$ACTOR" -n 500 --pretty=format:'%ae' | grep -v 'noreply.github.com' | head -n 1)
            
            if validate_email "$HISTORY_EMAIL"; then
              echo "‚úÖ Found valid email in Git History."
              FOUND_EMAIL="$HISTORY_EMAIL"
            fi
          fi

          # [Final Fallback]
          if [[ -z "$FOUND_EMAIL" ]]; then
            echo "‚ö†Ô∏è No real email found in Payload, API, or History."
            echo "‚ö†Ô∏è User '$ACTOR' likely has 'Keep my email private' enabled permanently."
            echo "‚ö†Ô∏è Using Default Fallback."
            FOUND_EMAIL="$DEFAULT_EMAIL"
          fi

          echo "----------------------------------------"
          echo "üéØ Final Resolved Recipient: $FOUND_EMAIL"
          echo "----------------------------------------"
          
          echo "recipient=$FOUND_EMAIL" >> $GITHUB_OUTPUT


      - name: Send mail (Sonar result)
        if: always() && steps.email.outputs.recipient != ''
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}

          from: "SonarQube Alerts <${{ secrets.MAIL_FROM }}>"
          to: ${{ steps.email.outputs.recipient }}
          cc: ${{ secrets.MAIL_CC }}

          subject: >
            ${{ job.status == 'success'
                && '‚úÖ SonarQube PASSED'
                || '‚ùå SonarQube FAILED' }}
            | ${{ github.repository }} | ${{ github.ref_name }}

          body: |
            Hello,
            
            SonarQube scan completed for your recent code changes.
            
            Repository : ${{ github.repository }}
            Branch     : ${{ github.ref_name }}
            Commit     : ${{ github.sha }}
            Status     : ${{ job.status }}
            
            SonarQube Dashboard:
            ${{ secrets.SONAR_HOST_URL }}/dashboard?id=${{ secrets.PROJECT_KEY }}
            
            ---
            This is an automated message from SonarQube CI/CD pipeline.

